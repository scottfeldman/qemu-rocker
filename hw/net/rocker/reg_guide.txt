Rocker Network Switch Register Programming Guide
Version 0.1, 4/21/2014


SECTION 1: Introduction
=======================

Overview
--------

This document describes the registers and provides bit descriptions information
about the Rocker Network Switch device.

Notations and Conventions
-------------------------

o In register descriptions, [n:m] indicates a range from bit n to bit m,
inclusive.
o Use of leading 0x indicates a hexadecimal number.
o Use of leading 0b indicates a binary number.
o The use of RSVD or Reserved indicates that a bit or field is reserved for
future use.
o Field wide is in bytes, unless otherwise noted.
o Register are (R) read-only, (R/W) read/write, (W) write-only, or (COR) clear
on read

SECTION 2: PCI Configuration Registers
======================================

PCI Configuration Space
-----------------------

Each switch instance registers as a PCI device with PCI configuration space:

	offset	wide	description		value
	---------------------------------------------
	0x0	2	Vendor ID		0x0666*
	0x2	2	Device ID		0x0001
	0x4	4	Command/Status
	0x8	1	Revision ID		0x01
	0x9	3	Class code		0x2800
	0xC	1	Cache line size
	0xD	1	Latency timer
	0xE	1	Header type
	0xF	1	Built-in self test
	0x10	4	Base address low
	0x14	4	Base address high
	0x18-28		Reserved
	0x2C	2	Subsystem vendor ID	0x0000
	0x2E	2	Subsystem ID		0x0000
	0x30-38		Reserved
	0x3C	1	Interrupt line
	0x3D	1	Interrupt pin		0x01
	0x3E	1	Min grant		0x00
	0x3D	1	Max latency		0x00
	0x40	1	TRDY timeout
	0x41	1	Retry count
	0x42	2	Reserved

* Not registered with PCI SIG (fictitious vendor)


SECTION 3: Ports
================

Physical, Virtual, and Logical Ports
------------------------------------

The switch supports up to 62 physical (front-panel) ports.  Register
PORT_PHYS_COUNT returns the actual number of physical ports available:

	PORT_PHYS_COUNT, offset 0x001c, 32-bit, (R)

In addition to physical ports, the switch supports virtual ports representing
higher-level constructs such as LAG, tunnels, or L2 bridges.

The switch maps logical ports to physical and virtual ports.  A special CPU
port is assigned logical port 0.  The physical ports are mapped to logical
ports 1-62.  A special loopback port is assigned logical port 63.  Virtual
ports are assigned logical ports 64-511.  The switch only uses logical port
references.  To summarize the mapping:

	logical port	mapping
	-------------------------------------------------------
	0		CPU port (for packets to/from host CPU)
	1-62		front-panel physical ports
	63		loopback port
	64-511		virtual ports

Switch Port Mode
----------------

Switch front-panel ports will operate in one of two modes: OpenFlow mode or
L2/L3 legacy mode.  Across the switch, a mix of port modes is allowed for
hybrid (OpenFlow and legacy) operation.  To set the mode for front-panel ports,
write to PORT_PHYS_MODE:

	PORT_PHYS_MODE, offset 0x0020, 64-bit, (R/W)

	Value is bitmap of first 64 logical ports.  Bits 0 and 63 are ignored
	and always read as 0.  Write 1 for OpenFlow mode; write 0 for legacy
	mode.  Default is 0.  Register should be set during switch
	initialization.  Changing port mode post-initialization will result
	in undefined behaviour.


SECTION 4: Interrupts, DMA, and Endianess
=========================================

PCI Interrupts
--------------

Two registers manage interrupt state and source:

	IRQ_MASK: interrupt mask register
	IRQ_STAT: interrupt status register, clear-on-read

Software should install the Interrupt Service Routine (ISR) before any ports
are enabled.  On receiving an interrupt, the ISR will read IRQ_STAT register to
get interrupt source.  IRQ_STAT uses clear-on-read semantics giving software
race-free access to interrupt status.  Any interrupt sources firing after
IRQ_STAT read will arm the device to generate another interrupts once device
interrupts are unmasked at the CPU when ISR exits.  There is no need to
enable/disable interrupt sources in the ISR.

IRQ_MASK is used to enable/disable particular interrupt sources.

IRQ_MASK and IRQ_STAT and share the following bit definitions:

	IRQ_MASK, offset 0x0010, 32-bit, (R/W)
	IRQ_STAT, offset 0x0014, 32-bit, (COR)

	bit	name			description
	------------------------------------------------------------------------
	0	IRQ_LINK		Link status changed on one or more ports
	1	IRQ_TX_DMA_DONE		Transmit DMA operation complete
	2	IRQ_RX_DMA_DONE		Receive DMA operation complete
	3	IRQ_CMD_DMA_DONE	Command DMA operation complete
	4	IRQ_EVENT_DMA_DONE	Async event DMA operation complete
	[5:31]	Reserved

DMA Operations
--------------

DMA operations are used for packet DMA to/from the CPU, command and event
processing.  Command processing includes statistical counters and table dumps,
table insertion/deletion, and more.  Event processing provides an async
notification method for device-originated events.  Each DMA operation has a set
of control registers to manage a descriptor and completion ring pair.  The
descriptor and completion rings are allocated from contiguous host DMA-able
memory and registers specify the rings base address as well as current head and
tail indices.  For descriptor rings, software writes and hardware reads.  For
completion rings, hardware writes and software reads.  Spliting processing
between the ring pair minimizes cache contention with any descriptor having a
single writer.

A generation bit in each completion descriptor marks hardware's progression
through the descriptor ring.  Each time the ring wraps, the generation bit is
toggled.  The generation bit allows software to know which descriptors are DMA
complete.  Software must also toggle its sense of the generation bit each pass
through the ring to remain synchronized with hardware.  Hardware will write '1'
to generation bit on first pass through ring, so software should zero-set
completion ring memory.

Descriptor/completion ring sizes must be a power of 2 and range from 2 to 64K
entries.  Descriptor and completion ring sizes must be the same for a given DMA
operation.  Each descriptor ring will have these registers:

	DMA_DESC_xxx_BASE_ADDR, offset 0x0100 + (x * 16), 64-bit, (R/W)
	DMA_COMP_xxx_BASE_ADDR, offset 0x0108 + (x * 16), 64-bit, (R/W)
	DMA_DESC_xxx_SIZE, offset 0x0110 + (x * 16), 32-bit, (R/W)
	DMA_DESC_xxx_HEAD, offset 0x0114 + (x * 16), 32-bit, (R/W)
	DMA_DESC_xxx_TAIL, offset 0x0118 + (x * 16), 32-bit, (R/W)
	DMA_DESC_xxx_CTRL, offset 0x011c + (x * 16), 32-bit, (R/W)

Where x is descriptor ring index:

	index		ring
	--------------------
	0		TX
	1		RX
	2		CMD	
	3		EVENT
	[4-7]		Reserved

All descriptor types share some common fields:

	field			wide	description
	-------------------------------------------------------------------
	DMA_DESC_BUF_ADDR	4	Phys addr of desc payload
	DMA_DESC_BUF_SIZE	2	Desc payload size in bytes
	DMA_DESC_COOKIE		2	Desc cookie for completion matching

All completion types share some common fields: 

	field			wide	description
	-------------------------------------------------------------------
	DMA_COMP_COOKIE		2	Cookie matching desc
	DMA_COMP_GEN		2	Generation bit
	DMA_COMP_RESULT		2	Result of desc processing

Additional descriptor and completion fields are type-specfic and covered in
later sections.

Endianess
---------

Siwtch can be enabled for big- or little-endian mode to avoid byte swapping by
host CPU of multi-byte fields within registers, DMA descriptors, and non-packet
DMA buffers.  Packet buffers and PCI configuration space registers are excluded
from swapping.  Packet buffers are always in network-order (big-endian).

Switch default is little-endian.  Software can set endianess mode at switch
initialization time by writing to ENDIANESS_SEL register, without worrying
about current byte-swapping mode, an endian-neutral value.

	ENDIANESS_SEL, offset 0x0018, 32-bit, (R/W)

	0x00000000	little-endian mode
	0x01000001	big-endian mode



SECTION 5: Configuration
========================




o switch mode: OF vs. legacy L2/L3
o set port mac address
o link status change port register
o port current speed, port max speed
o port OFPPC_NO_RECV, OFPPC_NO_FWD, OFPPFL_NO_PACKET_IN














