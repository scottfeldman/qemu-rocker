Rocker Network Switch Register Programming Guide
Scott Feldman <sfeldma@cumulusnetworks.com>
Neil Horman <nhorman@tuxdriver.com>
Version 0.1, 4/21/2014


SECTION 1: Introduction
=======================

Overview
--------

This document describes the registers and provides bit descriptions information
about the Rocker Network Switch device.

Notations and Conventions
-------------------------

o In register descriptions, [n:m] indicates a range from bit n to bit m,
inclusive.
o Use of leading 0x indicates a hexadecimal number.
o Use of leading 0b indicates a binary number.
o The use of RSVD or Reserved indicates that a bit or field is reserved for
future use.
o Field width is in bytes, unless otherwise noted.
o Register are (R) read-only, (R/W) read/write, (W) write-only, or (COR) clear
on read


SECTION 2: PCI Configuration Registers
======================================

PCI Configuration Space
-----------------------

Each switch instance registers as a PCI device with PCI configuration space:

	offset	width	description		value
	---------------------------------------------
	0x0	2	Vendor ID		0x1b36
	0x2	2	Device ID		0x0006
	0x4	4	Command/Status
	0x8	1	Revision ID		0x01
	0x9	3	Class code		0x2800
	0xC	1	Cache line size
	0xD	1	Latency timer
	0xE	1	Header type
	0xF	1	Built-in self test
	0x10	4	Base address low
	0x14	4	Base address high
	0x18-28		Reserved
	0x2C	2	Subsystem vendor ID	0x0000
	0x2E	2	Subsystem ID		0x0000
	0x30-38		Reserved
	0x3C	1	Interrupt line
	0x3D	1	Interrupt pin		0x01
	0x3E	1	Min grant		0x00
	0x3D	1	Max latency		0x00
	0x40	1	TRDY timeout
	0x41	1	Retry count
	0x42	2	Reserved


SECTION 3: Memory-Mapped Register Space
=======================================

A single memory-mapped BAR0 is defined to map device's register space and is
0x1000 in size.  The host BIOS will assign the base address location.  The host
driver/OS will map the base address to host memory, giving the driver mmio
access to the device register space.

All registers are 4 or 8 bytes long.  It is assumed host software will access 4
byte registers with one 4-byte access, and 8 byte registers with either two
4-byte accesses or a single 8-byte access.  In the case of two 4-byte accesses,
access must be lower and then upper 4-bytes, in that order.

The 0x1000 device register space is organized as follows:

	offset		description
	----------------------------------------------------
	0x0000-0x000f	Bogus registers to catch misbehaving
			drivers.  Writes do nothing.  Reads
			back as 0xDEADBABE.
	0x0010-0x00ff	Test registers
	0x0100-0x01ff	Descriptor control
	0x0200-0x02ff	Interrupt support
	0x0300-0x03ff	General purpose registers

Holes in register space are reserved.  Writes to reserved registers do nothing.
Reads to reserved registers read back as 0.

No fancy stuff like write-combining is enabled on any of the reigsters.


SECTION 4: Interrupts, DMA, and Endianess
=========================================

PCI Interrupts
--------------

Two registers manage interrupt state and source (cause):

	IRQ_MASK: interrupt mask register
	IRQ_STAT: interrupt status register, clear-on-read

Software should install the Interrupt Service Routine (ISR) before any ports
are enabled.  On receiving an interrupt, the ISR will read IRQ_STAT register to
get interrupt source.  IRQ_STAT uses clear-on-read semantics giving software
race-free access to interrupt status.  Any interrupt sources firing after
IRQ_STAT read will arm the device to generate another interrupts once device
interrupts are unmasked at the CPU when ISR exits.  There is no need to
enable/disable interrupt sources in the ISR.

IRQ_MASK is used to enable/disable particular interrupt sources.

IRQ_MASK and IRQ_STAT and share the following bit definitions:

	IRQ_MASK, offset 0x0200, 32-bit, (R/W)
	IRQ_STAT, offset 0x0204, 32-bit, (COR)

	bit	name			description
	------------------------------------------------------------------------
	0	IRQ_LINK		Link status changed on one or more ports
	1	IRQ_TX_DMA_DONE		Transmit DMA operation complete
	2	IRQ_RX_DMA_DONE		Receive DMA operation complete
	3	IRQ_CMD_DMA_DONE	Command DMA operation complete
	4	IRQ_EVENT_DMA_DONE	Async event DMA operation complete
	5	IRQ_TEST_DMA_DONE	Test DMA operation complete
	[6:31]	Reserved

DMA Operations
--------------

DMA operations are used for packet DMA to/from the CPU, command and event
processing.  Command processing includes statistical counters and table dumps,
table insertion/deletion, and more.  Event processing provides an async
notification method for device-originating events.  Each DMA operation has a set
of control registers to manage a descriptor ring.  The descriptor rings are
allocated from contiguous host DMA-able memory and registers specify the rings
base address as well as current head and tail indices.  Software always writes
the head, and hardware always writes the tail.

A generation bit in each descriptors comp_err field marks hardware's progression
through the descriptor ring.  Each time the ring wraps, the generation bit is
toggled.  The generation bit allows software to know which descriptors are DMA
complete.  Software must also toggle its sense of the generation bit each pass
through the ring to remain synchronized with hardware.  Hardware will write '1'
to generation bit on first pass through ring, so software should zero-set
descriptor ring memory to be syncronized with hardware.  Next pass hardware
writes '1', and so on.  When updating the comp_err, hardware writes the
generation bit last, after all other fields are written.  This ensures software
reads correct field values after reading a generation bit change.

Descriptor ring sizes must be a power of 2 and range from 2 to 64K entries.
Descriptor rings' base address must be 8-byte aligned.  Descriptors must be
packed within ring.  Each descriptor in each ring must also be aligned on an 8
byte boundary.  Each descriptor ring will have these registers:

	DMA_DESC_xxx_BASE_ADDR, offset 0x0100 + (x * 32), 64-bit, (R/W)
	DMA_DESC_xxx_SIZE, offset 0x0108 + (x * 32), 32-bit, (R/W)
	DMA_DESC_xxx_HEAD, offset 0x010c + (x * 32), 32-bit, (R/W)
	DMA_DESC_xxx_TAIL, offset 0x0110 + (x * 32), 32-bit, (R)
	DMA_DESC_xxx_CTRL, offset 0x0114 + (x * 32), 32-bit, (R/W)
	DMA_DESC_xxx_RSVD1, offset 0x0118 + (x * 32), 32-bit, (R/W)
	DMA_DESC_xxx_RSVD2, offset 0x011c + (x * 32), 32-bit, (R/W)

Where x is descriptor ring index:

	index		ring
	--------------------
	0		TX
	1		RX
	2		CMD	
	3		EVENT
	[4-7]		Reserved

Writing BASE_ADDR or SIZE will reset HEAD and TAIL to zero.  HEAD cannot be
written passed TAIL.  To do so would wrap the ring.  An empty ring is when HEAD
== TAIL.  A full ring is when HEAD is one position behind TAIL.  Both HEAD and
TAIL increment and modulo wrap at the ring size.

All descriptor types share some common fields:

	field			width	description
	-------------------------------------------------------------------
	DMA_DESC_BUF_ADDR	8	Phys addr of desc payload, 8-byte
					aligned
	DMA_DESC_COOKIE		8	Desc cookie for completion matching,
					upper-most bit is reserved
	DMA_DESC_BUF_SIZE	2	Desc payload size in bytes
	DMA_DESC_TLV_SIZE	2	Desc payload total size in bytes
					used for TLVs.  Must be <=
					DMA_DESC_BUF_SIZE.
	DMA_DESC_COMP_ERR	2	Completion status of associated
					desc payload.  High order bit is
					clear on new descs, toggled by
					hw for completed items.

To support forward- and backward-compatibility, descriptor and completion
payloads are specified in TLV format.  Fields are packed with Type=field name,
Length=field length, and Value=field value.  Software will ignore unknown fields
filled in by the switch.  Likewise, the switch will ignore unknown fields
filled in by software.

Descriptor payload buffer is 8-byte aligned and TLVs are 8-byte aligned.  The
value within a TLV is also 8-byte aligned.  The (packed, 8 byte) TLV header is:

	field	width	description
	-----------------------------
	type	4	TLV type
	len	2	TLV value length
	pad	2	Reserved

The alignment requirements for descriptors and TLVs are to avoid unaligned
access exceptions in software.  Note that the payload for each TLV is also
8 byte aligned.

Figure 1 shows an example descriptor buffer with two TLVs.

                  <------- 8 bytes ------->                                      
                                                                                 
  8-byte  +––––+  +–––––––––––+–––––+–––––+                     +–+              
  align           |   type    | len | pad |    TLV#1 hdr          |              
                  +–––––––––––+–––––+–––––+    (len=22)           |              
                  |                       |                       |              
                  |  value                |    TVL#1 value        |              
                  |                       |    (padded to 8-byte  |              
                  |                 +–––––+     alignment)        |              
                  |                 |/////|                       |              
   8-byte +––––+  +–––––––––––+–––––––––––+                       |              
   align          |   type    | len | pad |    TLV#2 hdr    DESC_BUF_SIZE
                  +–––––+–––––+–––––+–––––+    (len=2)            |              
                  |value|/////////////////|    TLV#2 value        |              
                  +–––––+/////////////////|                       |              
                  |///////////////////////|                       |              
                  |///////////////////////|                       |              
                  |///////////////////////|                       |              
                  |////////unused/////////|                       |              
                  |////////space//////////|                       |              
                  |///////////////////////|                       |              
                  |///////////////////////|                       |              
                  |///////////////////////|                       |              
                  +–––––––––––––––––––––––+                     +–+              

				fig. 1

TLVs can be nested within the NEST TLV type.

Control
-------

This register is used for low level control of the switch.

	CONTROL, offset 0x0300, 32-bit, (W)

	bit	name			description
	------------------------------------------------------------------------
    0   CONTROL_RESET    If set, device will perform reset (same as pci reset)
	[1:31]	Reserved


SECTION 5: Test Registers
=========================

Rocker switch has several test registers to support troubleshooting register
access, interrupt generation, and DMA operations:

	TEST_REG, offset 0x0010, 32-bit (R/W)
	TEST_REG64, offset 0x0018, 64-bit (R/W)
	TEST_IRQ, offset 0x0020, 32-bit (R/W)
	TEST_DMA_ADDR, offset 0x0028, 64-bit (R/W)
	TEST_DMA_SIZE, offset 0x0030, 32-bit (R/W)
	TEST_DMA_CTRL, offset 0x0034, 32-bit (R/W)

Reads to TEST_REG and TEST_REG64 will read a value 2x the last value written to
the register.  The 32-bit and 64-bit versions are for testing 32-bit and 64-bit
host accesses.

Bits written to TEST_IRQ will cause same (unmasked) bits to be written to
IRQ_STAT and an interrupt generated.  Use IRQ_MASK to mask and unmask
particular bits.

To test basic DMA operations, allocate a DMA-able host buffer and put the
buffer address into TEST_DMA_ADDR and size into TEST_DMA_SIZE.  Then, write to
TEST_DMA_CTRL to manipulate the buffer contents.  TEST_DMA_CTRL operations are:

	operation		value	description
	-----------------------------------------------------------
	TEST_DMA_CTRL_CLEAR	1	clear buffer
	TEST_DMA_CTRL_FILL	2	fill buffer bytes with 0x96
	TEST_DMA_CTRL_INVERT	4	invert bytes in buffer

Various buffer address and sizes should be tested to verify no address boundary
issue exists.  In particular, buffers that start on odd-8-byte boudary and/or
span multiple PAGE sizes should be tested.


SECTION 6: Ports
================

Physical, Virtual, and Logical Ports
------------------------------------

The switch supports up to 62 physical (front-panel) ports.  Register
PORT_PHYS_COUNT returns the actual number of physical ports available:

	PORT_PHYS_COUNT, offset 0x0304, 32-bit, (R)

In addition to front-panel ports, the switch supports virtual ports
representing higher-level constructs such as trunks and L2 bridges, as well as
tunnel ports.

Front-panel ports, virtual ports, and tunnel ports are mapped into a single
32-bit logical port space.  A special CPU port is assigned logical port 0.  The
front-panel ports are mapped to logical ports 1-62.  A special loopback port is
assigned logical port 63.  Virtual ports are assigned logical ports
64-0x0000ffff.  Tunnel ports are assigned logical ports 0x0001000-0x0001ffff.
The switch only uses logical port references.  To summarize the mapping:

	logical port		mapping
	-------------------------------------------------------
	0			CPU port (for packets to/from host CPU)
	1-62			front-panel physical ports
	63			loopback port
	64-0x0000ffff		virtual ports
	0x00010000-0x0001ffff	tunnel ports
        0x00020000-0xffffffff   RSVD

Physical Port Mode
------------------

Switch front-panel ports operate in a mode.  Current modes are Flow and L2/L3.
Across the switch, a mix of port modes is allowed for hybrid operation.  To
set/get the mode for front-panel ports, see port settings, below.

Port Settings
-------------

Links status for all front-panel ports is available via PORT_PHYS_LINK_STATUS:

	PORT_PHYS_LINK_STATUS, offset 0x0310, 64-bit, (R)

	Value is logical port bitmap.  Bits 0 and 63 always read 0.  Bits 1-62
	read 1 for link UP and 0 for link DOWN for respective front-panel ports.

Other properties for front-panel ports are available via DMA CMD descriptors:

	Get PORT_SETTINGS descriptor:

		field		width	description
		----------------------------------------------
		PORT_SETTINGS	2	CMD_GET
		LPORT		4	Logical port #

	Get PORT_SETTINGS completion:	

		field		width	description
		----------------------------------------------
		LPORT		4	Logical port #
		SPEED		4	Current port interface speed, in Mbps
		DUPLEX		1	1 = Full, 0 = Half
		AUTONEG		1	1 = enabled, 0 = disabled
		MACADDR		6	Port MAC address
		MODE		1	0 = Flow
					1 = L2/L3

	Set PORT_SETTINGS descriptor:

		field		width	description
		----------------------------------------------
		PORT_SETTINGS	2	CMD_SET
		LPORT		4	Logical port #
		SPEED		4	Port interface speed, in Mbps
		DUPLEX		1	1 = Full, 0 = Half
		AUTONEG		1	1 = enabled, 0 = disabled
		MACADDR		6	Port MAC address
		MODE		1	0 = Flow
					1 = L2/L3

Port Enable
-----------

Front-panel ports are initially disabled, which means port ingress and egress
packets will be dropped.  To enable or disable a port, use PORT_PHYS_ENABLE:

	PORT_PHYS_ENABLE: offset 0x0318, 64-bit, (R/W)

	Value is bitmap of first 64 logical ports.  Bits 0 and 63 are ignored
	and always read as 0.  Write 1 to enable port; write 0 to disable it.
	Default is 0.

SECTION 7: Switch Control
=========================

This section covers switch-wide register settings.

Switch ID
---------

The switch has a SWITCH_ID to be used by software to uniquely identify the
switch:

	SWITCH_ID: offset 0x0320, 64-bit, (R)

	Value is opaque to switch software and no special encoding is implied.


SECTION 8: CPU Packet Processing
================================

For packets ingressing on switch ports that are not forwarded by the switch but
rather directed to the host CPU for further processing are delievered in the
DMA RX ring.  Likewise, for host CPU originating packets destined to egress on
switch ports onto the network are scheduled by software using the DMA TX ring.

Tx Packet Processing
--------------------

Software schedules packets for egress on switch ports using the DMA TX ring.  A
TX descriptor buffer describes the packet location and size in host DMA-able
memory, the destination port, and any hardware-offload functions (such as L3
payload checksum offload).  Software then bumps the descriptor head to signal
hardware of new Tx work.  In response, hardware will DMA read Tx descriptors up
to head, DMA read descriptor buffer and packet data, perform offloading
functions, and finally frame packet on wire (network).  Once packet processing
is complete, hardware will writeback status to descriptor(s) to signal to
software that Tx is complete and software resources (e.g. skb) backing packet
can be released.

Figure 2 shows an example 3-fragment packet queued with one Tx descriptor.  A
TLV is used for each packet fragment.

	                                           pkt frag 1        
	                                           +–––––––+  +–+   
	                                       +–––+       |    |   
	                         desc buf      |   |       |    |   
	                        +––––––––+     |   |       |    |   
	        Tx ring     +–––+        +–––––+   |       |    |   
	      +–––––––––+   |   |  TLVs  |         +–––––––+    |   
	      |         +–––+   +––––––––+         pkt frag 2   |   
	      | desc 0  |       |        +–––––+   +–––––––+    |   
	      +–––––––––+       |  TLVs  |     +–––+       |    |   
	head+–+         |       +––––––––+         |       |    |   
	      | desc 1  |       |        +–––––+   +–––––––+    |pkt
	      +–––––––––+       |  TLVs  |     |                |   
	      |         |       +––––––––+     |   pkt frag 3   |   
	      |         |                      |   +–––––––+    |   
	      +–––––––––+                      +–––+       |    |   
	      |         |                          |       |    |   
	      |         |                          |       |    |   
	      +–––––––––+                          |       |    |   
	      |         |                          |       |    |   
	      |         |                          |       |    |   
	      +–––––––––+                          |       |    |   
	      |         |                          +–––––––+  +–+   
	      |         |                                           
	      +–––––––––+                                             

				fig 2.

The TLVs for Tx descriptor buffer are:

	field			width	description
	---------------------------------------------------------------------
	LPORT			4	Destination logical port #
	TX_OFFLOAD		1	Hardware offload modes:
					  0: no offload
					  1: insert IP csum (ipv4 only)
					  2: insert TCP/UDP csum
					  3: L3 csum calc and insert
                        	             into csum offset (TX_L3_CSUM_OFF)
                 	                    16-bit 1's complement csum value.
                                	     IPv4 pseudo-header and IP
                        	             already calculated by OS
                  	                   and inserted.
					  4: TSO (TCP Segmentation Offload)
	TX_L3_CSUM_OFF		2	For L3 csum offload mode, the offset,
					from the beginning of the packet,
					of the csum field in the L3 header
	TX_TSO_MSS		2	For TSO offload mode, the
					Maximum Segment Size in bytes
        TX_TSO_HDR_LEN		2	For TSO offload mode, the
					length of ethernet, IP, and
					TCP/UDP headers, including IP
					and TCP options.
	TX_FRAGS		<array>	Packet fragments
	  TX_FRAG		<nest>	Packet fragment
	    TX_FRAG_ADDR	8	DMA address of packet fragment
	    TX_FRAG_LEN		2	Packet fragment length

Possible status return codes in descriptor on completion are:

	DESC_COMP_ERR	reason
	--------------------------------------------------------------------
	0		OK
	ENXIO		address or data read err on desc buf or packet
			fragment
	EINVAL		bad lport or TSO or csum offloading error
	ENOMEM		no memory for internal staging tx fragment

Rx Packet Processing
--------------------

For packets ingressing on switch ports that are not forwarded by the switch but
rather directed to the host CPU for further processing are delievered in the
DMA RX ring.  Rx descriptor buffers are allocated by software and placed on the
ring.  Hardware will fill Rx descriptor buffers with packet data, write the
completion, and signal to software that a new packet is ready.  Since Rx packet
size is not known a-priori, the Rx descriptor buffer must be allocated for
worst-case packet size.  A single Rx descriptor will contain the entire Rx
packet data in one RX_PACKET TLV.  Other Rx TLVs describe and hardware offloads
performed on the packet, such as checksum validation.

The TLVs for Rx descriptor buffer are:

	field		width	description
	---------------------------------------------------
	LPORT		4	Source logical port #
	RX_FLAGS	2	Packet parsing flags:
				  (1 << 0): IPv4 packet
				  (1 << 1): IPv6 packet
				  (1 << 2): csum calculated
				  (1 << 3): IPv4 csum good
				  (1 << 4): IP fragment
				  (1 << 5): TCP packet
				  (1 << 6): UDP packet
				  (1 << 7): TCP/UDP csum good
	RX_CSUM		2	IP calculated checksum:
				  IPv4: IP payload csum
				  IPv6: header and payload csum
				(Only valid is RX_FLAGS:csum calc is set)
	RX_PACKET	<var>	Packet data

Possible status return codes in descriptor on completion are:

	DESC_COMP_ERR	reason
	--------------------------------------------------------------------
	0		OK
	ENXIO		address or data read err on desc buf
	ENOMEM		no memory for internal staging desc buf
	EMSGSIZE	Rx descriptor buffer wasn't big enough to contain
			pactet data TLV and other TLVs.


SECTION 9: Flow Mode
========================

Flow mode allows the switch to offload Flow packet processing functions to
hardware.  An Flow controller would communicate with an Flow agent installed on
the host.  The Flow agent would (directly or indirectly) communicate with the
Rocker switch driver, which in turn would program switch hardware with Flow
functionality.  The block diagram is:

		+–––––––––––––––----–––+
		|                      |
		|  Remote Controller   |
		+––––––––+––----–––––––+
		         |          
		         |          
		+––––––––+–––––––––+
		|                  |
		|   Local Agent    |
		+––––––––––––––––––+
		|                  |
		|   Rocker Driver  |
		+––––––––––––––––––+
		    <this spec>       
		+––––––––––––––––––+
		|                  |
		|   Rocker Switch  |
		+––––––––––––––––––+

The switch interface for Flow is roughly modeled from Broadcom's OF-DPA API.
To participate in Flow functions, ports must be configure for Flow mode during
switch initialization.

Flow Table Interface
--------------------

There are commands to add, modify, delete, and get stats of flow table entries.
The commands are issued using the DMA CMD descriptor ring.  The following
commands are defined:

	CMD_ADD:		add an entry to flow table
	CMD_MOD:		modify an entry in flow table
	CMD_DEL:		delete an entry from flow table
	CMD_GET_STATS:		get stats for flow entry

TLVs for add and modify commands are:

	field		width	description
	--------------------------------------------------
	FLOW_CMD	2	CMD_[ADD|MOD]
	FLOW_TBL	2	Flow table ID
				  0: ingress port
				  10: vlan
				  20: termination mac
				  30: unicast routing
				  40: multicast routing
				  50: bridging
				  60: ACL policy
	FLOW_PRIORITY	4	Flow priority
	FLOW_HARDTIME	4	Hard timeout for flow
	FLOW_IDLETIME	4	Idle timeout for flow
	FLOW_COOKIE	8	Cookie
	FLOW_xxx	<var>	Nested flow entry TLVs.

FLOW_xxx nested TLVs are defined below:

	field			width	description
	----------------------------------------------------
	FLOW_IG_PORT			nest
	  FLOW_IN_LPORT		4	ingress port number
	  FLOW_GOTO_TBL		2	goto table ID; zero to drop

	field			width	description
	----------------------------------------------------
	FLOW_VLAN			nest
	  FLOW_IN_LPORT		4	ingress port number
	  FLOW_VLAN_ID		2	vlan ID
	  FLOW_VLAN_ID_MASK	2	vlan ID mask
	  FLOW_GOTO_TBL		2	goto table ID; zero to drop
	  FLOW_NEW_VLAN_ID	2	new vlan ID

	field			width	description
	----------------------------------------------------
	FLOW_TERM_MAC			nest
	  FLOW_IN_LPORT		4	ingress port number
	  FLOW_IN_LPORT_MASK	4	ingress port number mask
	  FLOW_ETHERTYPE	2	must be either 0x0800 or 0x86dd
	  FLOW_DST_MAC		6	destination MAC
	  FLOW_DST_MAC_MASK	6	destination MAC mask
	  FLOW_VLAN_ID		2	vlan ID
	  FLOW_VLAN_ID_MASK	2	vlan ID mask
	  FLOW_GOTO_TBL		2	only acceptable values are
					unicast or multicast routing
					table IDs
	  FLOW_OUT_LPORT	2	if specified, must be controller,
					set zero otherwise

	field			width	description
	----------------------------------------------------
	FLOW_BRIDGING			nest
	  FLOW_VLAN_ID		2	vlan ID
	  FLOW_TUNNEL_ID	4	tunnel ID
	  FLOW_DST_MAC		6	destination MAC
	  FLOW_DST_MAC_MASK	6	destination MAC mask
	  FLOW_GOTO_TBL		2	goto table ID; zero to drop
	  FLOW_GROUP_ID		4	data for GROUP action must
					be a L2 Interface, L2
					Multicast, L2 Flood,
					or L2 Overlay group entry
					as appropriate
	  FLOW_TUN_LOG_LPORT	4	unicast Tenant Bridging
					flows specify a tunnel
					logical port ID
	  FLOW_OUT_LPORT	2	data for OUTPUT action,
					restricted to CONTROLLER,
					set to 0 otherwise

	field			width	description
	----------------------------------------------------
	FLOW_UNICAST_ROUTING		nest
	  FLOW_ETHERTYPE	2	must be either 0x0800 or 0x86dd
	  FLOW_DST_IP		4	destination IPv4 address
					stored in host byte order.
					Must be unicast address
	  FLOW_DST_IP_MASK	4	IP mask stored in host byte
					order. Must be prefix mask
	  FLOW_DST_IPV6		16	destination IPv6 address
					stored in host byte order.
					Must be unicast address
	  FLOW_DST_IPV6_MASK	16	IPv6 mask stored in host byte
					order. Must be prefix mask
	  FLOW_GOTO_TBL		2	goto table ID; zero to drop
	  FLOW_GROUP_ID		4	data for GROUP action must
					be an L3 Unicast group entry

	field			width	description
	----------------------------------------------------
	FLOW_MULTICAST_ROUTING		nest
	  FLOW_ETHERTYPE	2	must be either 0x0800 or 0x86dd
	  FLOW_VLAN_ID		2	vlan ID
	  FLOW_SRC_IP		4	source IPv4 address stored
					in host byte order. Optional,
					can contain IPv4 address,
					must be completely masked
					if not used
	  FLOW_SRC_IP_MASK	4	IP Mask stored in host byte
					order
	  FLOW_DST_IP		4	destination IPv4 address
					stored in host byte order.
					Must be multicast address
	  FLOW_SRC_IPV6		16	source IPv6 Address. Optional.
					Can contain IPv6 address,
					must be completely masked
					if not used
	  FLOW_SRC_IPV6_MASK	16	IPv6 mask stored in host byte
	  FLOW_DST_IPV6		16	destination IPv6 Address. Must
					be multicast address
					Must be multicast address
	  FLOW_GOTO_TBL		2	goto table ID; zero to drop
	  FLOW_GROUP_ID		4	data for GROUP action must
					be an L3 multicast group entry

	field			width	description
	----------------------------------------------------
	FLOW_ACL			nest
	  FLOW_IN_LPORT		4	ingress port number
	  FLOW_IN_LPORT_MASK	4	ingress port number mask
	  FLOW_ETHERTYPE	2	ethertype
	  FLOW_VLAN_ID		2	vlan ID
	  FLOW_VLAN_ID_MASK	2	vlan ID mask
	  FLOW_VLAN_PCP		2	vlan Priority Code Point
	  FLOW_VLAN_PCP_MASK	2	vlan Priority Code Point mask
	  FLOW_SRC_MAC		6	source MAC
	  FLOW_SRC_MAC_MASK	6	source MAC mask
	  FLOW_DST_MAC		6	destination MAC
	  FLOW_DST_MAC_MASK	6	destination MAC mask
	  FLOW_TUNNEL_ID	4	tunnel ID
	  FLOW_SRC_IP		4	source IPv4 address stored
					in host byte order. Optional,
					can contain IPv4 address,
					must be completely masked
					if not used
	  FLOW_SRC_IP_MASK	4	IP Mask stored in host byte
					order
	  FLOW_DST_IP		4	destination IPv4 address
					stored in host byte order.
					Must be multicast address
	  FLOW_DST_IP_MASK	4	IP Mask stored in host byte
					order
	  FLOW_SRC_IPV6		16	source IPv6 Address. Optional.
					Can contain IPv6 address,
					must be completely masked
					if not used
	  FLOW_SRC_IPV6_MASK	16	IPv6 mask stored in host byte
	  FLOW_DST_IPV6		16	destination IPv6 Address. Must
					be multicast address
					Must be multicast address
	  FLOW_DST_IPV6_MASK	16	IPv6 mask stored in host byte
	  FLOW_SRC_ARP_IP	4	source IPv4 address in the ARP
					payload.  Only used if ethertype
					== 0x0806.
	  FLOW_SRC_ARP_IP_MASK	4	IP Mask stored in host byte
					order
	  FLOW_IP_PROTO		2	IP protocol
	  FLOW_IP_PROTO_MASK	2	IP protocol mask
	  FLOW_DSCP		2	DSCP
	  FLOW_DSCP_MASK	2	DSCP mask
	  FLOW_ECN		2	ECN
	  FLOW_ECN_MASK		2	ECN mask
	  FLOW_L4_SRC_PORT	2	L4 source port, only for
					TCP, UDP, or SCTP
	  FLOW_L4_SRC_PORT_MASK	2	L4 source port mask
	  FLOW_L4_DST_PORT	2	L4 source port, only for
					TCP, UDP, or SCTP
	  FLOW_L4_DST_PORT_MASK	2	L4 source port mask
	  FLOW_ICMP_TYPE	1	ICMP type, only if IP protocol is 1
	  FLOW_ICMP_TYPE_MASK	1	ICMP type mask
	  FLOW_ICMP_CODE	1	ICMP code
	  FLOW_ICMP_CODE_MASK	1	ICMP code mask
	  FLOW_IPV6_LABEL	4	IPv6 flow label
	  FLOW_IPV6_LABEL_MASK	4	IPv6 flow label mask
	  FLOW_GROUP_ID		4	data for GROUP action
	  FLOW_QUEUE_ID_ACTION	1	write the queue ID
	  FLOW_NEW_QUEUE_ID	1	queue ID
	  FLOW_VLAN_PCP_ACTION	1	write the VLAN priority
	  FLOW_NEW_VLAN_PCP	1	VLAN priority
	  FLOW_DSCP_ACTION	1	write the DSCP
	  FLOW_NEW_DSCP		1	new DSCP
	  FLOW_TUN_LOG_LPORT	4	restrct to valid tunnel
					logical port, set to 0
					otherwise.
	  FLOW_OUT_LPORT	2	data for OUTPUT action,
					restricted to CONTROLLER,
					set to 0 otherwise
	  FLOW_CLEAR_ACTIONS	4	if 1 packets matching flow are
					dropped (all other instructions
					ignored)

TLVs for flow delete and get stats command are:

	field		width	description
	---------------------------------------------------
	FLOW_CMD	2	CMD_[DEL|GET_STATS]
	FLOW_COOKIE	8	Cookie

On completion of get stats command, the descriptor buffer is written back with
the following TLVs:

	field			width	description
	---------------------------------------------------
	FLOW_STAT_DURATION	4	Flow duration
	FLOW_STAT_RX_PKTS	8	Received packets
	FLOW_STAT_TX_PKTS	8	Transmit packets

Possible status return codes in descriptor on completion are:

	DESC_COMP_ERR	command			reason
	--------------------------------------------------------------------
	0		all			OK
	EFAULT		all			head or tail index outside
						of ring
	ENXIO		all			address or data read err on
						desc buf
	EMSGSIZE	GET_STATS		cmd descriptor buffer wasn't
						big enough to contain write-back
						TLVs
	EINVAL		all			invalid parameters passed in
	EEXIST		ADD			entry already exists
	ENOSPC		ADD			no space left in flow table
	ENOENT		MOD|DEL|GET_STATS	cookie invalid

Group Table Interface
---------------------

There are commands to add, modify, delete, and get stats of group table
entries.  The commands are issued using the DMA CMD descriptor ring.  The
following commands are defined:

	CMD_ADD:		add an entry to group table
	CMD_MOD:		modify an entry in group table
	CMD_DEL:		delete an entry from group table
	CMD_GET_STATS:		get stats for group entry

TLVs for add and modify commands are:

	field			width	description
	-----------------------------------------------------------
	FLOW_GROUP_CMD		2	CMD_[ADD|MOD]
	FLOW_GROUP_ID		2	Flow group ID
	FLOW_GROUP_TYPE		1	Group type:
					  0: L2 interface
					  1: L2 rewrite
					  2: L3 unicast
					  3: L2 multicast
					  4: L2 flood
					  5: L3 interface
					  6: L3 multicast
					  7: L3 ECMP
					  8: L2 overlay
	FLOW_VLAN_ID		2	Vlan ID (types 0, 3, 4, 6)
	FLOW_L2_PORT		2	Port (types 0)
	FLOW_INDEX		4	Index (all types but 0)
	FLOW_OVERLAY_TYPE	1	Overlay sub-type (type 8):
					  0: Flood unicast tunnel
					  1: Flood multicast tunnel
					  2: Multicast unicast tunnel
					  3: Multicast multicast tunnel
	FLOW_GROUP_ACTION		nest
	  FLOW_GROUP_ID		2	next group ID in chain (all
					types except 0)
	  FLOW_OUT_PORT		4	egress port (types 0, 8)
	  FLOW_POP_VLAN_TAG	1	strip outer VLAN tag (type 1
					only)
	  FLOW_VLAN_ID		2	(types 1, 5)
	  FLOW_SRC_MAC		6	(types 1, 2, 5) 
	  FLOW_DST_MAC		6	(types 1, 2) 

TLVs for flow delete and get stats command are:

	field			width	description
	-----------------------------------------------------------
	FLOW_GROUP_CMD		2	CMD_[DEL|GET_STATS]
	FLOW_GROUP_ID		2	Flow group ID

On completion of get stats command, the descriptor buffer is written back with
the following TLVs:

	field			width	description
	---------------------------------------------------
	FLOW_GROUP_ID		2	Flow group ID
	FLOW_STAT_DURATION	4	Flow duration
	FLOW_STAT_REF_COUNT	4	Flow reference count
	FLOW_STAT_BUCKET_COUNT	4	Flow bucket acount 

Possible status return codes in descriptor on completion are:

	DESC_COMP_ERR	command			reason
	--------------------------------------------------------------------
	0		all			OK
	EFAULT		all			head or tail index outside
						of ring
	ENXIO		all			address or data read err on
						desc buf
	ENOSPC		GET_STATS		cmd descriptor buffer wasn't
						big enough to contain write-back
						TLVs
	EINVAL		ADD|MOD			invalid parameters passed in
	EEXIST		ADD			entry already exists
	ENOSPC		ADD			no space left in flow table
	ENOENT		MOD|DEL|GET_STATS	group ID invalid
	EBUSY		DEL			group reference count non-zero
	ENODEV		ADD			next group ID doesn't exist

SECTION 10: L2/L3 Mode
============================

Trunking
--------

Trunking is a method by which front-panel ports (members) can be bundled
together to form a trunk, a new virtual port.  The switch supports commands to
add, modify, and delete trunks and trunk members.  Trunk commands are issued
using the DMA CMD descriptor ring.

TLVs for CMD_ADD and CMD_MOD are:

	field		width	description
	---------------------------------------------------
	CMD		2	CMD_[ADD|MOD]
	TRUNK_LPORT	2	(MOD command only) Existing trunk logical
				port number
	TRUNK_HASH	2	Trunk egress hashing algorithm:
				  0: distribute based on source MAC address
				  1: distribute based on destination MAC address
				  2: distribute based on source and
				     destination MAC addresses
				  3: distribute based on source IP address
				  4: distribute based on destination IP address
				  5: distribute based on source and
				     destination IP addresses
	TRUNK_MEMBER	8	Trunk member lport bitmap; only
				front-panel port bits should be set.
				Ports must be in L2/L3 mode.
	TRUNK_ACTIVE	8	Trunk member lport active bitmap; only
				front-panel port bits should be set,
				and must be a subset of TRUNK_MEMBERS.
				Non-active members are excluded from
				egress hash distribution.  Non-active
				members will still be able to send
				and receive control protocol packets.
	
On completion of CMD_ADD comamnd, the descriptor buffer is written back
with the logical port number of the new trunk:

	field		width	description
	---------------------------------------------------
	TRUNK_LPORT	2	Trunk logical port

TLVs for CMD_DEL are:

	field		width	description
	---------------------------------------------------
	CMD		2	CMD_DEL
	TRUNK_LPORT	2	Existing trunk logical port number

Possible status return codes in descriptor on completion are:

	DESC_COMP_ERR	command			reason
	--------------------------------------------------------------------
	0		all			OK
	EINVAL		ADD|MOD			invalid parameters passed in
	EEXIST		ADD|MOD			another trunk already has
						one or more of the member ports
	ENOSPC		ADD			no space left for new trunk
	ENOENT		MOD|DEL			trunk lport does not exists

Bridging
--------

A bridge groups logical ports into a L2 network.  The switch supports multiple
bridges and each bridge is new logical port.  A bridge may optionally have a
VLAN ID assigned, but only one bridge for a given VLAN ID  (or no VLAN ID) is
allowed.  Bridge member ports can include trunk logical ports and physical
front-panel ports.  The switch supports command to add, modify, and delete
bridges and bridge members.  Bridge commands are issued using DMA CMD
descriptor ring.

TLVs for CMD_ADD and CMD_MOD are:

	field		width	description
	---------------------------------------------------
	CMD		2	CMD_[ADD|MOD]
	BRIDGE_LPORT	2	(MOD command only) Existing bridge logical
				port number
	BRIDGE_MEMBER	8	Bridge member lport bitmap;
				Front-panel ports must be in L2/L3
				mode.

xxx add DEL cmd

Tunneling
---------

xxx TODO

L3 Routing
----------

xxx TODO

ACL
---

xxx TODO
